
# Java Garbage Collection & Memory Leaks  
## Step-by-Step Interview Notes (7+ Years Experience)

---

## 1. What Garbage Collection (GC) Really Is

Garbage Collection is the JVM process that:
- Identifies objects no longer reachable
- Frees heap memory automatically
- Prevents manual memory management

GC does NOT:
- Track business usage
- Remove references
- Guess developer intent

---

## 2. GC Root Concept (MOST IMPORTANT)

GC starts from GC Roots:
- Local variables (stack)
- Static fields
- Active threads
- JNI references

Rule:
If an object is reachable from any GC root, it is LIVE.

---

## 3. Step-by-Step: How GC Works

![gc_working.png](..%2Fimages%2Fgc_working.png)

1. JVM identifies GC roots  
2. Marks all reachable objects  
3. Sweeps unreachable objects  
4. Compacts memory (collector dependent)

---

## 4. Why GC Cannot Remove Unused References

GC works on reachability, not usage.

```java
static List<User> users = new ArrayList<>();
```
Static fields are GC roots.  
Even unused objects remain reachable.

---

## 5. What Is a Memory Leak in Java?

Objects that are:
- Logically unused
- Technically reachable

GC is correct; reference handling is wrong.

---

## 6. Step-by-Step: How Memory Leaks Happen

![memory_leak_flow.png](..%2Fimages%2Fmemory_leak_flow.png)


1. Object created  
2. Reference stored in long-lived object  
3. Business logic finishes  
4. Reference never cleared  
5. GC cannot reclaim memory  

---

## 7. Types of Memory Leaks & Fixes

### 7.1 Static Field Leaks
❌ Static fields live forever  
✅ Avoid unnecessary static data

---

### 7.2 Unbounded Cache Leaks
❌ HashMap without eviction  
✅ Use size limits / TTL

---

### 7.3 Listener Leaks
❌ Listeners never deregistered  
✅ Always unregister listeners

---

### 7.4 ThreadLocal Leaks
❌ Thread pool threads live long  
✅ Always call remove()

---

### 7.5 Inner Class Leaks
❌ Non-static inner class holds outer reference  
✅ Prefer static inner classes

---

### 7.6 ClassLoader Leaks
❌ Static references prevent class unloading  
✅ Clean resources on shutdown

---

## 8. GC Issue vs Memory Leak

| GC Issue | Memory Leak |
|--------|-------------|
| Heap stable | Heap grows |
| CPU spikes | OOM over time |
| GC tuning helps | Code fix required |

---

## 9. Detecting Memory Leaks

- Monitor heap growth
- Capture heap dump
- Analyze with MAT or VisualVM

---

## 10. Best Practices

- Avoid static references
- Clean ThreadLocals
- Use weak references
- Deregister listeners
- Close resources

---

## 11. Interview One-Liners

- GC removes unreachable objects
- Memory leaks are due to references
- Java leaks memory logically

---

## 12. Final Takeaway

GC is conservative by design.  
Memory leaks are developer responsibility.

---
