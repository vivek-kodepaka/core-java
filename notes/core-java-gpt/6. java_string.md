# Java String ‚Äì Complete Notes & Interview Questions (Senior-Level)

> **Target audience:** 6‚Äì8+ years Java developers (Java 8 ‚Üí 21)

---

## 1. What is a String in Java?

In Java, `String` is a **sequence of characters** represented by the `java.lang.String` class.

```java
String s = "Java";
```

### Key Properties
- **Immutable**
- Stored in **String Constant Pool (SCP)**
- Implements `CharSequence`, `Comparable<String>`, `Serializable`
- Thread-safe by design (because immutable)

---

## 2. Why String is Immutable?

### Definition
Once a `String` object is created, its **value cannot be changed**.

```java
String s = "Java";
s.concat(" World");
System.out.println(s); // Java
```

### Problems Immutability Solves

#### 1Ô∏è‚É£ Security
Used in:
- ClassLoader
- File paths
- Network URLs

- ‚ÄúEven if the object is immutable, the reference variable can be changed by Thread-2 to point to a hacked URL. So how is this secure?‚Äù
- Security relies on the fact that the reference used after validation is not shared or mutated.
- Immutability protects the object, not careless reference sharing.
-   ```text
       void readFile(String path) {
    if (path.startsWith("/usr/bin")) {
        // validated
    }
    File file = new File(path);
    file.read();
    }
    ```
- What‚Äôs happening internally
- path is a local variable
- Each thread has its own stack
- Thread-2 cannot access or change Thread-1‚Äôs local variable

## design issue 
    
```java
class Config {
static String path = "/usr/bin";
}

```

```text
if (Config.path.startsWith("/usr/bin")) {
    // validated
}
use(Config.path);

```

```thread-2
Config.path = "/etc/passwd";

```

- Shared mutable reference
- Validation and use are separated
- This is NOT a String problem ‚Äî this is a design bug


```java
String path = "/usr/bin";
```
If mutable ‚Üí attacker could modify path reference.

## Real Security Guarantee (precise wording)

Once a String object is validated and the reference to that object is safely held (local/final), no thread can alter the validated content.


Immutability guarantees that the validated String object cannot be altered.
Reference reassignment is a separate concurrency concern and must be handled by proper scoping and synchronization. Java‚Äôs security-critical APIs validate and immediately consume immutable Strings, avoiding shared mutable references.
---

#### 2Ô∏è‚É£ String Pool Optimization
Reuse same object ‚Üí saves memory.

```java
String a = "Java";
String b = "Java";
// a == b ‚Üí true
```

---

#### 3Ô∏è‚É£ Thread Safety
Multiple threads can safely share String objects.

- because state of object won't change , we dont have setter on string 
- if we append new string created (reference is not immutable --> if want add final)

---

#### 4Ô∏è‚É£ HashCode Caching
```java
String s = "Java";
s.hashCode(); // cached
```
Used heavily in `HashMap`.

---

## 3. String Constant Pool (SCP)

### What is SCP?
A special memory area inside **Heap** that stores **unique String literals**.

```java
String s1 = "Java";
String s2 = "Java";
```

Only **one object** created.

---

### SCP vs Heap Objects

```java
String s1 = "Java";
String s2 = new String("Java");
```

- `s1` ‚Üí SCP
- `s2` ‚Üí Heap

`==` ‚Üí false
`equals()` ‚Üí true

---

## 4. String Creation Ways

```java
String a = "Java";              // SCP
String b = new String("Java");  // Heap
char[] c = {'J','a','v','a'};
String d = new String(c);
```

---

## 5. == vs equals()

| Operator | Checks |
|--------|-------|
| `==` | Reference equality |
| `equals()` | Content equality |

```java
String a = "Java";
String b = new String("Java");

System.out.println(a == b);      // false
System.out.println(a.equals(b)); // true
```

---

## 6. intern() Method

Moves String to SCP.

```java
String s = new String("Java");
String t = s.intern();
```

`t` points to SCP object.

---

## 7. String Memory Diagram (Conceptual)

```
SCP:      "Java"  <---- t
Heap:     new String("Java") <---- s
```

---

## 8. Why String is final?

- Prevent subclass from breaking immutability
- Prevent overriding `hashCode()` / `equals()`
- Security reasons

---

## 9. String vs StringBuilder vs StringBuffer

| Feature | String | StringBuilder | StringBuffer |
|------|-------|--------------|---------------|
| Mutability | Immutable | Mutable | Mutable |
| Thread-safe | Yes | No | Yes |
| Performance | Slow | Fastest | Slower |

---

### Example

```java
String s = "A";
s += "B"; // new object

StringBuilder sb = new StringBuilder("A");
sb.append("B"); // same object
```

---

## 10. Why String Concatenation is Slow in Loop?

```java
String s = "";
for(int i=0;i<1000;i++) {
    s += i;
}
```

Creates **1000+ objects**.

### Optimized Version

```java
StringBuilder sb = new StringBuilder();
for(int i=0;i<1000;i++) {
    sb.append(i);
}
```

---

## 11. Compile-time vs Runtime Concatenation

```java
String a = "Java" + "World"; // compile-time
String b = "Java";
String c = b + "World";       // runtime
```

---

## 12. String is Thread-safe ‚Äì Explain

Immutability ensures:
- No shared-state mutation
- No synchronization required

---

## 13. String in HashMap

```java
Map<String, Integer> map = new HashMap<>();
map.put("Java", 1);
```

Why String is ideal key?
- Immutable
- Cached hashCode
  - For String, the result of hashCode() is computed once and then stored (cached) inside the String object.
    Subsequent calls return the stored value instead of recomputing it.
  - String obj doesnt change --> hash never change --> no need to compute every time --> compute once and store in object cache 

```text
String s = "Java";

int h1 = s.hashCode(); // calculated
int h2 = s.hashCode(); // returned from cache

```

##Hash Map Performance
    
- ```text 
    Map<String, String> map = new HashMap<>();
    map.put("Java", "Language");
  ```

- HashMap calls:
  - hashCode() multiple times
  - sometimes during resize
  - during lookup

üëâ Cached hashCode avoids recomputation ‚Üí huge performance gain

* map.put("Java", 1);
  - HashMap internally does:
    - Call key.hashCode()
    - Convert it to a bucket index
    - Store entry in that bucket
* map.get("Java");
  - HashMap again does:
  - Call key.hashCode()
  - Go to same bucket
  - Use equals() to find exact key
  - üìå hashCode() is called MANY times

---

## 14. Common String Methods (Interview Focus)

- `length()`
- `charAt()`
- `substring()`
- `contains()`
- `indexOf()`
- `split()`
- `replace()`
- `toCharArray()`
- `trim()` / `strip()` (Java 11)

---

## 15. Java 9+ String Changes

### Compact Strings
- Stored as **byte[]** instead of `char[]`
- Uses **LATIN-1** or **UTF-16**

Memory optimization.

---

## 16. Common Interview Questions (WITH ANSWERS)

### Q1. Why String is immutable?
**Security, caching, thread-safety, SCP optimization**

---

### Q2. Difference between == and equals?
- `==` ‚Üí reference
- `equals()` ‚Üí content

---

### Q3. How many objects created?

```java
String s = new String("Java");
```
**Answer:** 2 (Heap + SCP if not exists)

---

### Q4. What is String Pool?
A special memory area that stores unique string literals.

---

### Q5. Why StringBuilder is faster than StringBuffer?
Because it is **not synchronized**.

---

### Q6. Is String thread-safe?
Yes, because it is immutable.

---

### Q7. Can String be extended?
No, it is `final`.

---

### Q8. What happens when we modify String?
A **new object** is created.

---

### Q9. Difference between new String() and literal?
Literal ‚Üí SCP
new ‚Üí Heap

---

### Q10. Why String is preferred as HashMap key?
Immutable + cached hashCode.

---

### Q11. What is intern()?
Moves String to SCP.

---

### Q12. StringBuilder thread safety?
Not thread-safe.

---

### Q13. How substring worked before Java 7?
Shared original char array ‚Üí memory leak risk.

---

### Q14. How substring works now?
Creates **new array copy**.

---

### Q15. What is Compact String?
Java 9 optimization using `byte[]`.

---

## 17. Senior-Level Interview Traps

- String immutability ‚â† thread safety for reference
- `final` reference ‚â† immutable object
- SCP is inside heap (not permgen since Java 8)

---

## 18. One-line Interview Summary

> String is immutable, final, pool-based, thread-safe by design, optimized for memory, security, and performance.

---

## 19. When to Use What

- **String** ‚Üí constants, keys
- **StringBuilder** ‚Üí loops, performance
- **StringBuffer** ‚Üí legacy thread-safe code

---

### ‚úÖ END OF NOTES

