
# Java Memory Management & Memory Leaks  
## Interview Notes for 7+ Years Experience

## 1. Overview of Java Memory Model
Java memory is managed by the JVM, but incorrect references can still cause leaks.

Main memory areas:
- Stack
- Heap
- Metaspace
- Code Cache
- Native (Off-Heap) Memory
![img.png](..%2Fimages%2Fimg.png)

![java_memory_areas.png](..%2Fimages%2Fjava_memory_areas.png)

---

## 2. Stack Memory
Stores:
- Method call frames
- Local primitives
- Object references

Characteristics:
- Thread specific
- No GC
- Fast allocation

Common error:
- StackOverflowError

---

## 3. Heap Memory
Stores all objects and arrays.
Shared across threads.
Managed by Garbage Collector.

### Heap Generations
- Young (Eden, Survivor)
- Old Generation

---

## 4. Metaspace
Stores class metadata.
Uses native memory.
Common error:
- OutOfMemoryError: Metaspace

---

## 5. Code Cache
Stores JIT compiled code.
Rarely tuned.

---

## 6. Native / Off-Heap Memory
Examples:
- Direct ByteBuffers
- JNI
- Thread stacks

---

## 7. Garbage Collection Basics
GC removes unreachable objects.
Collectors: G1GC, ZGC (awareness).

---

## 7.1  stack vs heap

Stack memory is thread-local and automatically cleaned on method return, so it’s fast and cannot leak. Heap memory is shared, stores objects, and is managed by the garbage collector, which makes it flexible but susceptible to memory leaks.”

| Aspect | Stack | Heap |
|------|------|------|
| Memory type | Thread-local | Shared across threads |
| Size | Fixed per thread | Large, configurable |
| Allocation | Automatic (method call) | Dynamic (new keyword) |
| Deallocation | Automatic (method return) | Garbage Collection |
| GC involvement | ❌ No | ✅ Yes |
| Speed | Very fast | Slower than stack |
| Stores | Local variables, references | Objects, arrays |
| Lifetime | Method scope | Application-defined |
| Memory leak | ❌ Impossible | ✅ Possible |
| Error type | StackOverflowError | OutOfMemoryError |
| Tuning flag | `-Xss` | `-Xms`, `-Xmx` |
| Thread safety | Inherently thread-safe | Requires synchronization |
| Example | `int x = 10;` | `new User()` |


| Question | Stack | Heap |
|--------|------|------|
| Is GC involved? | No | Yes |
| Can memory leak happen? | No | Yes |
| Who manages it? | JVM runtime | Garbage Collector |
| Scope | Method-level | Object-level |
| Typical failure | StackOverflowError | OutOfMemoryError |

## Tuning Flags (Senior Awareness)

| Memory | JVM Flag | Meaning |
|------|----------|---------|
| Stack | -Xss | Stack size per thread |
| Heap | -Xms | Initial heap size |
| Heap | -Xmx | Maximum heap size |


GC works only on:
Heap memory
Stack memory is:
Managed by JVM runtime
Cleaned automatically on method exit
Outside GC’s responsibility

## 8. What is a Memory Leak?
Objects no longer used but still referenced.

---

## 9. Common Causes of Memory Leaks
- Static references
- Unbounded caches
- Listeners not removed
- Non-static inner classes
- ClassLoader leaks
- ThreadLocal misuse

---

## 10. Detecting Memory Leaks
Symptoms:
- Increasing heap usage
- Frequent Full GC
- OOM after long runtime

Tools:
- jmap
- jstack
- VisualVM
- Eclipse MAT

---

## 11. Preventing Memory Leaks
- Avoid unnecessary static fields
- Use cache eviction
- Remove listeners
- Clear ThreadLocal
  - in real life we use Thread pools , threads wont dies -> lives forever
  - so if we add any thing in this thread --> it stays forever
    - so clear context we thread task done
      - ```text
            @KafkaListener(topics = "orders")
            public void consume(String msg) {
            try {
            // process message
            } finally {
            MDC.clear();
            SecurityContextHolder.clearContext();
            }
            }
        ```
        - ```text
               try {
               runnable.run();
               } finally {
               MDC.clear();
               SecurityContextHolder.clearContext();
            }
          ```

- Prefer static inner classes
  - for non-static inner classes --> reference (jvm does)--> to outer class
  - so even if outer does nt need it wont be GC (if we add inner in cache--> big problem)
- Close resources

---

## 12. Reference Types
- Strong
- Soft
- Weak
- Phantom

---

## 13. Interview One-Liners
- Java can leak memory despite GC
- Leaks are due to references
- Heap dump analysis is key

---

## 14. Final Takeaway
Senior Java devs should detect and reason about memory leaks effectively.
