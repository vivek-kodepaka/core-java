# Java Exceptions – Complete Notes (10+ Years Experience)

---

## 1. What is an Exception?
An exception is an event that disrupts the normal flow of program execution. In Java, exceptions are objects that extend `Throwable`.

---

## 2. Exception Hierarchy
- `Throwable`
  - `Error` (unchecked, system-level)
  - `Exception`
    - Checked Exceptions
    - Unchecked Exceptions (`RuntimeException`)

---

## 3. Error vs Exception
| Aspect | Error | Exception |
|------|------|-----------|
| Recoverable | ❌ No | ✅ Yes |
| Handled by app | ❌ | ✅ |
| Examples | OOME, StackOverflow | IOException, NPE |

---

## 4. Checked vs Unchecked Exceptions

### Checked Exceptions
- Checked at compile time
- Must be handled or declared
- Example: `IOException`, `SQLException`

```java
void readFile() throws IOException { }
```

### Unchecked Exceptions
- Occur at runtime
- Extend `RuntimeException`
- Example: `NullPointerException`, `IllegalArgumentException`

---

## 5. Why Checked Exceptions Exist (Design Intent)
- Force caller to handle recoverable failures
- Explicit API contracts
- Better error propagation in IO, DB, network

---

## 6. Why RuntimeException Exists
- Programming errors
- Fail-fast behavior
- Avoid cluttering method signatures

---

## 7. try-catch-finally

```java
try {
    riskyOperation();
} catch (IOException e) {
    log.error(e.getMessage());
} finally {
    cleanup();
}
```

- `finally` always executes (except `System.exit()`)

---

## 8. Multiple catch (Java 7+)

```java
catch (IOException | SQLException e) {
}
```

---

## 9. try-with-resources (Java 7+)

```java
try (BufferedReader br = new BufferedReader(new FileReader(file))) {
    br.readLine();
}
```

- Auto-closes resources
- Uses `AutoCloseable`

---

## 10. Suppressed Exceptions

```java
Throwable[] suppressed = e.getSuppressed();
```

Occurs mainly in try-with-resources.

---

## 11. Exception Propagation

```java
methodA() -> methodB() -> methodC()
```
Exception propagates up the stack until handled.

---

## 12. Rethrowing Exceptions

```java
catch (IOException e) {
    throw e;
}
```

Java 7 supports precise rethrow.

---

## 13. Custom Exceptions

```java
class BusinessException extends RuntimeException {
    public BusinessException(String msg) {
        super(msg);
    }
}
```

Best practice: meaningful names + messages.

---

## 14. Exception Wrapping

```java
throw new ServiceException("failed", e);
```

Preserves root cause.

---

## 15. Checked to Unchecked Conversion

```java
catch (IOException e) {
    throw new RuntimeException(e);
}
```

Used in streams, lambdas.

---

## 16. Best Practices (Senior Level)
- Never swallow exceptions
- Log once, handle once
- Preserve stack trace
- Use domain-specific exceptions
- Avoid using Exception as catch-all

---

## 17. Performance Considerations
- Exception creation is expensive
- Don’t use exceptions for flow control
- Stack trace filling is costly

---

## 18. Exceptions in Streams & Lambdas
- Lambdas don’t support checked exceptions directly
- Use wrappers or convert to runtime

---

## 19. Exceptions in Multi-threading
- Exceptions in threads don’t propagate to parent
- Use `Future.get()` or `UncaughtExceptionHandler`

---

## 20. Real-World Production Patterns
- Global exception handler (Spring `@ControllerAdvice`)
- Error codes + messages
- Mapping exceptions to HTTP status

---

## 21. Common Anti-Patterns
- Empty catch block
- catch(Exception e)
- Logging and rethrowing without context

---

## 22. JVM & Stack Trace
- Stack trace captured at exception creation
- `fillInStackTrace()` cost

---

## 23. Final Thoughts
Exceptions are part of API design, not just error handling. Senior engineers design exception hierarchies deliberately.

---

✅ END OF THEORY + CODE NOTES

