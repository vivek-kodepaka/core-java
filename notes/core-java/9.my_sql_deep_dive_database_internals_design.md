# MySQL Deep Dive – Database Internals & Design (20+ Years Experience)

> **Audience**: Senior / Staff / Principal engineers (15–20+ yrs)
>
> **Scope**: MySQL (OLTP focus). MongoDB / Cosmos DB will be covered later.
>
> **Goal**: Real-world design, internals, performance, reliability, and interview-level depth.

---

## 1. How a SQL Database Really Works (End-to-End)

### 1.1 Query Lifecycle
1. Client sends SQL
2. SQL parser → syntax tree
3. Optimizer → execution plan
4. Storage engine execution
5. Result set returned

Key point:
> **Optimizer decides *how*, not *what***

---

## 2. MySQL Architecture (Internals)

### 2.1 Server Layer
- Parser
- Optimizer
- Query cache (deprecated / removed)
- Execution engine

### 2.2 Storage Engines
| Engine | Use |
|------|----|
| InnoDB | Default, transactional |
| MyISAM | Legacy, read-heavy |
| Memory | Temporary tables |

**Rule**: Use **InnoDB always** (unless you know why not).

---

## 3. InnoDB Internals (VERY IMPORTANT)

### 3.1 Data Storage
- Tablespace → Pages (16 KB)
- B+ Tree indexes
- Clustered index

```text
Table
 └── Clustered Index (PRIMARY KEY)
     ├── Row Data
     └── Secondary Index pointers
```

Key insight:
> **Primary key defines physical row order**

---

### 3.2 Clustered vs Secondary Index

```sql
PRIMARY KEY (id)
INDEX idx_email (email)
```

- Clustered index → stores row
- Secondary index → stores PK pointer

Impact:
- Bigger PK = slower secondary index
- Random PK = page splits

**Industry rule**:
> Use **auto-increment / time-ordered PKs**

---

## 4. Indexing – Beyond Basics

### 4.1 B+ Tree Properties
- Height usually ≤ 3
- O(log N)
- Disk-friendly

### 4.2 Composite Indexes
```sql
INDEX idx_user_status_created (user_id, status, created_at)
```

Rules:
- Leftmost prefix matters
- Order columns by selectivity + query pattern

---

### 4.3 Covering Index
```sql
SELECT email FROM users WHERE status = 'ACTIVE';
```

If `email` + `status` in index → **no table lookup**

---

### 4.4 Index Anti-Patterns
❌ Too many indexes
❌ Low-cardinality indexes alone
❌ Indexing frequently updated columns blindly

---

## 5. Transactions (ACID – Real Meaning)

### 5.1 ACID in Practice
- **Atomicity** → undo logs
- **Consistency** → constraints
- **Isolation** → MVCC
- **Durability** → redo logs

---

### 5.2 Isolation Levels (Critical)

| Level | Issues |
|----|------|
| READ UNCOMMITTED | Dirty reads |
| READ COMMITTED | Non-repeatable |
| REPEATABLE READ | Phantom (MySQL special) |
| SERIALIZABLE | Locking |

MySQL default:
```sql
REPEATABLE READ
```

Key insight:
> MySQL prevents phantom reads using **next-key locks**

---

## 6. MVCC (Multi-Version Concurrency Control)

### 6.1 How Reads Don’t Block Writes
- Undo log stores old versions
- Read View decides visibility

```text
Transaction ID
Read View
Undo Log
```

This is why:
```sql
SELECT does not block UPDATE
```

---

## 7. Locking (Deep)

### 7.1 Lock Types
- Row lock
- Gap lock
- Next-key lock
- Intention locks

### 7.2 Gap Locks (Phantom Protection)
```sql
SELECT * FROM orders WHERE amount BETWEEN 100 AND 200 FOR UPDATE;
```

Locks gaps → prevents inserts

---

### 7.3 Deadlocks

Common causes:
- Different lock order
- Large transactions

MySQL behavior:
> Detects deadlock and kills **one** transaction

---

## 8. Query Optimization (Real World)

### 8.1 EXPLAIN (Must Know)
```sql
EXPLAIN ANALYZE SELECT ...
```

Key fields:
- type
- rows
- filtered
- extra

---

### 8.2 Common Performance Killers
❌ SELECT *
❌ Functions on indexed columns
❌ OR conditions
❌ Leading wildcards

---

## 9. Schema Design (Senior Level)

### 9.1 Normalization vs Denormalization
- Normalize for correctness
- Denormalize for performance (carefully)

### 9.2 Soft Deletes
```sql
deleted_at TIMESTAMP NULL
```

Index accordingly.

---

## 10. Data Types – Subtle Choices

| Type | Advice |
|----|------|
| INT vs BIGINT | Size matters |
| VARCHAR vs CHAR | Variable wins |
| DATETIME vs TIMESTAMP | Timezone aware |
| JSON | Use sparingly |

---

## 11. Pagination (VERY IMPORTANT)

### 11.1 Offset Pagination (Bad)
```sql
LIMIT 100000, 20;
```

### 11.2 Keyset Pagination (Good)
```sql
WHERE id > last_seen_id
LIMIT 20;
```

---

## 12. Scaling MySQL

### 12.1 Vertical Scaling
- Bigger CPU
- More RAM

### 12.2 Horizontal Scaling
- Read replicas
- Sharding (application-level)

---

## 13. Replication

### 13.1 Types
- Asynchronous
- Semi-sync
- GTID-based

### 13.2 Replication Lag
Causes:
- Large transactions
- Disk IO
- Single-threaded apply (older versions)

---

## 14. Backup & Recovery

### 14.1 Backup Types
- Logical (mysqldump)
- Physical (xtrabackup)

### 14.2 Point-in-Time Recovery
- Full backup + binlogs

---

## 15. High Availability

Patterns:
- Primary–Replica
- Failover
- ProxySQL
- Orchestrator

---

## 16. MySQL vs PostgreSQL (Executive Summary)

| Aspect | MySQL | Postgres |
|----|------|---------|
| Simplicity | High | Medium |
| JSON | Basic | Advanced |
| Extensions | Limited | Rich |

---

## 17. Security

- Least privilege
- Avoid root
- Parameterized queries
- Encryption at rest / transit

---

## 18. Production Checklist (Senior)

- Proper PKs
- Bounded transactions
- Index audits
- Slow query logs
- Backup validation
- Replication monitoring

---

## 19. Interview Cheat Sheet

- InnoDB = clustered index
- Secondary index stores PK
- MVCC via undo logs
- REPEATABLE READ default
- Gap locks prevent phantoms
- Index order matters

---

## 20. Final Mental Model

```
SQL correctness → schema
Performance     → indexes + queries
Scalability     → replication + design
Reliability     → backups + transactions
```

---

**Next**: MongoDB internals → Cosmos DB → Polyglot persistence

