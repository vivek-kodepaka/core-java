
# Java Keywords That Matter (7+ Years Experience)
## Explanation + Tricky Interview Questions

---

## 1. `static`
### What it really means
- Belongs to class, not object
- Lifetime = ClassLoader lifetime
- Acts as a GC Root

### Real-world usage
- Constants
- Utility methods
- Caches (⚠️ risky)

### Tricky interview questions
1. Why static fields cause memory leaks?
   * Static fields themselves don’t leak memory, but the objects they reference can, because static fields are reachable from the ClassLoader GC root and therefore live as long as the ClassLoader lives.
   * ```vbnet
       GC Root
       └── ClassLoader
          └── Class metadata
            └── static field
                └── object
     ```
   * static cache without eviction
     * Static → long-lived
     * Map → grows over time
     * No eviction → objects never released
     
2. When can static fields be GC’d?

---

## 2. `final`
### What it guarantees
- Variable: reference cannot change   (static final --> only one obj reference --> no memory leaks)
- Method: cannot be overridden
- Class: cannot be inherited

```text
final List<String> list = new ArrayList<>();
list.add("x"); // allowed
```

### Tricky interview questions
1. Why final fields are thread-safe after constructor?
2. Difference between final and immutable?

---

## 3. `volatile`
### What it guarantees
- Visibility across threads
- Prevents instruction reordering

```java
volatile int x;
x++; // NOT atomic
```

### Tricky interview questions
1. volatile vs synchronized?
2. Why volatile in double-checked locking?

---

## 4. `synchronized`
### What it provides
- Mutual exclusion
- Visibility

### Tricky interview questions
1. Can synchronized cause deadlock?
2. Method vs block synchronization?

---

## 5. `transient`
### Purpose
- Excludes fields from serialization

```java
transient String password;
```

### Tricky interview questions
1. What happens after deserialization?
2. Can we serialize transient manually?

---

## 6. `abstract`
- Partial implementation
- Template method pattern

## Problems without abstraction
- If we code directly against concrete classes:
  - Tight coupling
  - Hard to change implementations
  - Difficult to test (mocking pain)
  - Violates OCP & DIP
  - Code breaks when business rules evolve

- An abstract class represents an “is-a” relationship where:
  - Some behavior is common
  - Some behavior is left for subclasses
- Limitations of Abstract Class
  - Only single inheritance
  - Can hold state, which increases coupling
  - Not ideal for capability-based design

### Tricky interview questions
1. Can abstract class have constructor?
2. Abstract class vs interface?

---

## 7. `interface`
- Contract
- Loose coupling

- An interface defines a contract — what a class can do, not what it is.

### Java 8+
- default methods
- static methods
  
- Abstract classes solve code reuse and controlled inheritance, while interfaces solve loose coupling, multiple inheritance, and extensibility.
  In modern Java & Spring, interfaces are preferred, abstract classes are used when shared behavior is unavoidable.

| Feature        | Abstract Class               | Interface                   |
| -------------- | ---------------------------- | --------------------------- |
| Inheritance    | Single                       | Multiple                    |
| Methods        | Abstract + concrete          | Abstract + default + static |
| State          | Can have fields              | Constants only              |
| Use when       | Base class with shared logic | Capability / contract       |
| Spring prefers | ❌                            | ✅                           |
| Design focus   | **is-a**                     | **can-do**                  |

### Tricky interview questions
1. Diamond problem with default methods?
2. Can interface have state?

---

## 8. `this` and `super`
- `this` → current object
- `super` → parent access

### Tricky interview questions
1. Can this() and super() be used together?
2. Why super() must be first?

---

## 9. `native`
- Used for JNI

### Tricky interview questions
1. Are native methods thread-safe?
2. Why native exists?

---

## 10. Keywords You Can Ignore
- goto
- const

---

## 11. Interview Traps

❌ GC cleans static memory  
✅ GC cleans unreachable objects  

❌ volatile makes code thread-safe  
✅ volatile ensures visibility only  

---

## 12. Final Takeaway

> Senior engineers are judged on **when and why** they use keywords, not memorization.

---
